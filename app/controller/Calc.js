/*
 * File: app/controller/Calc.js
 *
 * This file was generated by Sencha Architect version 2.2.1.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Sencha Touch 2.2.x library, under independent license.
 * License of Sencha Architect does not include license for Sencha Touch 2.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('MyApp.controller.Calc', {
    extend: 'Ext.app.Controller',

    config: {
    },

    calc: function(type, shade, panes, width, height) {
        rolls = Ext.getStore('Rolls');

        var rolls = MyApp.app.getController('Inventory').getRoll(type, shade);

        var sizes = [], 
        results;

        Ext.each(rolls.getData().items, function(roll){
            sizes.push(roll.getData().Size);       
        });


        //returned array "bestRoll, linearFt, adjSqft, actSqft, excess, pull, scrap"
        singleCut = this.singleCut(sizes, panes, width, height);
        splitCut = this.splitCut(sizes, panes, width, height);


        excess1 = singleCut[4];
        excess2 = splitCut[4];


        if(isNaN(excess2)){
            results = singleCut;
        } else if ((excess1 <= 0) && (excess2 <= 0)) {
            results = singleCut;
        } else if (excess1 < 0) {
            results = splitCut;
        } else if (excess2 < 0) {
            results = singleCut;
        } else if (excess1 <= excess2) {
            results = singleCut;
        } else if (excess2 <= excess1) {
            results = splitCut;
        } else {
            console.log("error");
        }

        return results;


    },

    singleCut: function(sizes, panes, width, height) {

        sizes.sort(function(a,b){return a - b;});


        var splicePiece = [0, 0],
            widestSize = sizes[sizes.length - 1];

        if (width * height < 350) {
            pull = "French";
            bestWidth = this.closeRoll(sizes, width);
            adjWidth = bestWidth - width;
            adjHeight = bestHeight - height;
            leftWidth = adjWidth * height; //adds up remainder of film
            leftHeight = adjHeight * width;
            bestHeight = this.closeRoll(sizes, height);
            worstRoll = (leftWidth < leftHeight) ? height : width;
            bestRoll = (leftWidth < leftHeight) ? bestWidth : bestHeight;
            actSqft = panes * width * height / 12;
            adjSqft = panes * bestRoll * worstRoll / 144;
            linearFt = panes * worstRoll / 12;
            //tPrice = linearFt * filmType;
            scrap = [(leftWidth > leftHeight) ? bestHeight - height : bestWidth - width, (leftWidth > leftHeight) ? width * panes : height * panes];
            excess = scrap[0] * scrap[1];
        } else if ((width > widestSize) && (height > widestSize)) {
            pull = "Oversized 2";
            adjSqft = 0;
            excess = 0;
            bestRoll = widestSize;
            linearFt = 0;
            scrap = 0;
            actSqft = width * height * panes / 144;
            if (width > height) {
                splicePiece = [height - widestSize, width * panes];
                linearFt = width * panes / 12;
                height = widestSize;
            } else if (width < height) {
                splicePiece = [width - widestSize, height * panes];
                linearFt = height * panes / 12;
                width = widestSize;
            }
            //tPrice = linearFt * filmType;
        } else if ((width > widestSize) | (height > widestSize)) {
            pull = "Oversized 1";
            bestWidth = this.closeRoll(sizes, width);
            bestHeight = this.closeRoll(sizes, height);
            adjWidth = bestWidth - width;
            adjHeight = bestHeight - height;
            leftWidth = adjWidth * height; //adds up remainder of film
            leftHeight = adjHeight * width;
            bestRoll = (width < height) ? bestWidth : bestHeight; // chooses smalles close roll
            worstRoll = (width < height) ? height : width;
            actSqft = panes * width * height / 144;
            adjSqft = panes * bestRoll * worstRoll / 144;
            linearFt = panes * worstRoll / 12;
            //tPrice = linearFt * filmType;
            scrap = [(width < height) ? bestRoll - width : bestRoll - height, (width < height) ? height * panes : width * panes];
            excess = scrap[0] * scrap[1];
        } else {
            pull = "Normal";
            bestWidth = this.closeRoll(sizes, width);
            bestHeight = this.closeRoll(sizes, height);
            adjWidth = bestWidth - width;
            adjHeight = bestHeight - height;
            leftWidth = adjWidth * height; //adds up remainder of film
            leftHeight = adjHeight * width;
            bestRoll = (leftWidth < leftHeight) ? bestWidth : bestHeight;
            worstRoll = (leftWidth < leftHeight) ? height : width;
            actSqft = panes * width * height / 144;
            adjSqft = panes * bestRoll * worstRoll / 144;
            linearFt = worstRoll * panes / 12;
            //tPrice = linearFt * filmType;
            scrap = [(leftWidth > leftHeight) ? bestHeight - height : bestWidth - width, (leftWidth > leftHeight) ? width * panes : height * panes];
            excess = scrap[0] * scrap[1];
        } //End if-else

        return [bestRoll, linearFt, adjSqft, actSqft, excess, pull, scrap, splicePiece];
    },

    splitCut: function(sizes, panes, width, height) {
        loPiece = (panes % 2) * width * height;

        if (width * height < 350) {
            pull = "French";
            bestWidth = this.closeRoll2(sizes, width);
            bestHeight = this.closeRoll2(sizes, height);
            adjWidth = bestWidth - width;
            adjHeight = bestHeight - height;
            leftWidth = adjWidth * height; //adds up remainder of film
            leftHeight = adjHeight * width;
            worstRoll = (leftWidth < leftHeight) ? height : width;
            bestRoll = (leftWidth < leftHeight) ? bestWidth : bestHeight;
            actSqft = panes * width * height / 12;
            adjSqft = panes * bestRoll * worstRoll / 144;
            linearFt = worstRoll * ((panes + (panes % 2)) / 2) / 12;
            //tPrice = linearFt * filmType;
            scrap = [(leftWidth > leftHeight) ? bestHeight - height : bestWidth - width, (leftWidth > leftHeight) ? width * panes : height * panes];
            excess = scrap[0] * scrap[1] + loPiece;
            bestRoll *= 2;
        } else {
            pull = "Split roll";
            bestWidth = this.closeRoll2(sizes, width);
            bestHeight = this.closeRoll2(sizes, height);
            adjWidth = bestWidth - width;
            adjHeight = bestHeight - height;
            leftWidth = adjWidth * height; //adds up remainder of film
            leftHeight = adjHeight * width;

            bestRoll = (width < height) ? bestWidth : bestHeight; // chooses smalles close roll
            worstRoll = (width < height) ? height : width;

            actSqft = panes * width * height / 144;
            adjSqft = panes * bestRoll * worstRoll / 144;
            linearFt = worstRoll * ((panes + (panes % 2)) / 2) / 12;
            //tPrice = linearFt * filmType;
            scrap = [(width < height) ? bestRoll - width : bestRoll - height, (width < height) ? height * panes : width * panes];
            excess = ((scrap[0] * scrap[1]) * 2) + loPiece;
            bestRoll *= 2;
        } //End if-else

        return [bestRoll, linearFt, adjSqft, actSqft, excess, pull, scrap];
    },

    closeRoll: function(sizes, number) {
        //var rollArray = [36, 48, 60, 72];//array represents the 4 roll sizes of window film

        var closest = sizes.filter(function(ele){return ele-number >= 0;}).sort()[0];
        return closest;   
    },

    closeRoll2: function(sizes, number) {
        //var rollArray = [18, 24, 30, 36];//array represents the 4 roll sizes of window film

        halfSizes = [];

        Ext.each(sizes, function(size){halfSizes.push(size / 2);});

        var closest = halfSizes.filter(function(ele){return ele-number >= 0;}).sort()[0];

        return closest;   
    }

});